@page "/file-upload"
@using MemoARCenter.Services.Models
@rendermode InteractiveServer
@inject IJSRuntime JSRuntime


<div class="file-upload-container">
	<h3 class="header">Upload Images</h3>

	<div class="file-input-area">
		<InputFile enctype="multipart/form-data" id="file-input" OnChange="HandleImageSelected" Multiple="true" class="file-input" />
		<label for="file-input" class="file-upload-button">
			Select Images
		</label>
	</div>

	@if (uploadedImages.Count > 0)
	{
		<div class="preview-area">
			@foreach (var image in uploadedImages)
			{
				<div class="preview-item">
					<img src="@image.DataUrl" alt="@image.Name" class="preview-image" />
					<div class="video-selection-container">
						<button type="button" class="file-upload-button video-upload-button" @onclick="() => TriggerVideoInputClick(image.Name)">
							Select Video
						</button>
						<InputFile id="@($"video-input-{image.Name}")" class="file-input video-input hidden" OnChange="@((e) => HandleVideoSelected(e, image))" />

						@if (imageToVideoMap.ContainsKey(image) && imageToVideoMap[image] != null)
						{
							<div class="video-preview">
								<video src="@imageToVideoMap[image]?.DataUrl" class="preview-video" controls poster="@GetVideoPoster(imageToVideoMap[image])"></video>
								<p class="video-selected-indicator">Video Selected</p>
							</div>
						}
					</div>
				</div>

			}
		</div>
	}
	else
	{
		<p class="empty-preview">No images selected yet.</p>
	}

	<div class="button-area">
		<button @onclick="UploadImagesAndVideos" class="upload-button">Upload</button>
	</div>

	@if (!string.IsNullOrEmpty(uploadStatus))
	{
		<p class="upload-status">@uploadStatus</p>
	}
</div>

<script>
	window.triggerInputClick = (inputId) => {
		const inputFile = document.getElementById(inputId);
		if (inputFile) {
			inputFile.click();
		}
	};
</script>

@code {
	private List<FilePreviewModel> uploadedImages = new();
	private Dictionary<FilePreviewModel, FilePreviewModel?> imageToVideoMap = new();
	private string? uploadStatus;

	private async Task HandleImageSelected(InputFileChangeEventArgs e)
	{
		uploadedImages.Clear();
		imageToVideoMap.Clear();

		foreach (var file in e.GetMultipleFiles())
		{
			if (file == null || file.Size == 0 || !file.ContentType.StartsWith("image"))
				continue;

			using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // Max file size: 10MB
			using var memoryStream = new MemoryStream();
			await stream.CopyToAsync(memoryStream);

			var base64String = Convert.ToBase64String(memoryStream.ToArray());
			var contentType = file.ContentType;

			var imagePreview = new FilePreviewModel
				{
					Name = file.Name,
					DataUrl = $"data:{contentType};base64,{base64String}"
				};

			uploadedImages.Add(imagePreview);
			imageToVideoMap[imagePreview] = null; // Initialize with no video
		}
	}

	private async Task TriggerVideoInputClick(string imageName)
	{
		var inputId = $"video-input-{imageName}";
		await JSRuntime.InvokeVoidAsync("triggerInputClick", inputId);
	}

	private async Task HandleVideoSelected(InputFileChangeEventArgs e, FilePreviewModel image)
	{
		var videoFile = e.GetMultipleFiles().FirstOrDefault();
		if (videoFile == null || videoFile.Size == 0 || !videoFile.ContentType.StartsWith("video"))
			return;

		using var stream = videoFile.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // Max file size: 10MB
		using var memoryStream = new MemoryStream();
		await stream.CopyToAsync(memoryStream);

		var base64String = Convert.ToBase64String(memoryStream.ToArray());
		var contentType = videoFile.ContentType;

		var videoPreview = new FilePreviewModel
			{
				Name = videoFile.Name,
				DataUrl = $"data:{contentType};base64,{base64String}"
			};

		imageToVideoMap[image] = videoPreview; // Link the video to the image
	}

	private string GetVideoPoster(FilePreviewModel? video)
	{
		if (video == null || string.IsNullOrEmpty(video.DataUrl))
		{
			return "placeholder-image-url.png"; // Fallback placeholder image
		}

		return video.DataUrl; // For simplicity, use the same data URL as a poster
	}

	private async Task UploadImagesAndVideos()
	{
		if (uploadedImages.Count == 0)
		{
			uploadStatus = "No images selected.";
			return;
		}

		try
		{
			using var httpClient = new HttpClient();
			using var content = new MultipartFormDataContent();

			foreach (var image in uploadedImages)
			{
				if (!imageToVideoMap.ContainsKey(image) || imageToVideoMap[image] == null)
				{
					// Skip images without videos
					continue;
				}

				// Add image to the request
				var imageContent = new StreamContent(new MemoryStream(image.Content));
				imageContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(image.ContentType);
				content.Add(imageContent, "images", image.Name);

				// Add linked video to the request
				var video = imageToVideoMap[image]!;
				var videoContent = new StreamContent(new MemoryStream(video.Content));
				videoContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(video.ContentType);
				content.Add(videoContent, "videos", video.Name);
			}

			var response = await httpClient.PostAsync("https://0.0.0.0:7264/api/fileupload/bulkupload", content);

			if (response.IsSuccessStatusCode)
			{
				uploadStatus = "Images and videos uploaded successfully!";
			}
			else
			{
				uploadStatus = $"Upload failed. Status Code: {response.StatusCode}";
			}
		}
		catch (Exception ex)
		{
			uploadStatus = $"Error: {ex.Message}";
		}
	}
}
